import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import '../utils/console.dart';
import '../utils/config_paths.dart';

class OpenBaoService {
  final String address;
  final String? namespace;
  String? _token;

  OpenBaoService({
    required this.address,
    this.namespace,
    String? token,
    String? tokenPath,
  }) {
    _token = token;
    if (_token == null && tokenPath != null) {
      _loadTokenFromFile(tokenPath);
    }
  }

  void _loadTokenFromFile(String path) {
    final expandedPath = ConfigPaths.expandPath(path);
    final file = File(expandedPath);
    if (file.existsSync()) {
      _token = file.readAsStringSync().trim();
    }
  }

  Map<String, String> get _headers => {
    'X-Vault-Token': _token ?? '',
    'Content-Type': 'application/json',
    if (namespace != null) 'X-Vault-Namespace': namespace!,
  };

  Future<Map<String, String>> fetchSecrets(String secretPath) async {
    final url = Uri.parse('$address/v1/$secretPath');

    Console.info('Fetching secrets from OpenBao: $secretPath');

    try {
      final response = await http.get(url, headers: _headers);

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body) as Map<String, dynamic>;
        final secretData = data['data'] as Map<String, dynamic>?;

        if (secretData == null) {
          throw Exception('No data found at path: $secretPath');
        }

        // Handle KV v2 format
        if (secretData.containsKey('data')) {
          final kvData = secretData['data'] as Map<String, dynamic>;
          return kvData.map((k, v) => MapEntry(k, v.toString()));
        }

        // Handle KV v1 format
        return secretData.map((k, v) => MapEntry(k, v.toString()));
      } else if (response.statusCode == 403) {
        throw Exception('Permission denied. Check your OpenBao token.');
      } else if (response.statusCode == 404) {
        throw Exception('Secret not found at path: $secretPath');
      } else {
        throw Exception(
          'Failed to fetch secrets: ${response.statusCode} - ${response.body}',
        );
      }
    } on SocketException catch (e) {
      throw Exception('Cannot connect to OpenBao at $address: $e');
    }
  }

  Future<void> writeEnvFile(String secretPath, String envFilePath) async {
    final secrets = await fetchSecrets(secretPath);

    final buffer = StringBuffer();
    buffer.writeln('# Generated by dart_cloud_deploy from OpenBao');
    buffer.writeln('# Path: $secretPath');
    buffer.writeln('# Generated at: ${DateTime.now().toIso8601String()}');
    buffer.writeln('');

    for (final entry in secrets.entries) {
      final value = entry.value;
      // Quote values that contain spaces or special characters
      if (value.contains(' ') || value.contains('"') || value.contains("'")) {
        buffer.writeln('${entry.key}="${value.replaceAll('"', '\\"')}"');
      } else {
        buffer.writeln('${entry.key}=$value');
      }
    }

    final file = File(envFilePath);
    await file.writeAsString(buffer.toString());

    // Set restrictive permissions
    if (!Platform.isWindows) {
      await Process.run('chmod', ['600', envFilePath]);
    }

    Console.success(
      'Secrets written to $envFilePath (${secrets.length} variables)',
    );
  }

  Future<List<String>> listSecrets(String path) async {
    final url = Uri.parse('$address/v1/$path?list=true');

    try {
      final response = await http.get(url, headers: _headers);

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body) as Map<String, dynamic>;
        final keys = data['data']?['keys'] as List<dynamic>?;
        return keys?.map((k) => k.toString()).toList() ?? [];
      }
      return [];
    } catch (e) {
      Console.warning('Failed to list secrets at $path: $e');
      return [];
    }
  }

  Future<bool> checkHealth() async {
    try {
      final url = Uri.parse('$address/v1/sys/health');
      final response = await http.get(url);
      return response.statusCode == 200 || response.statusCode == 429;
    } catch (e) {
      return false;
    }
  }
}
