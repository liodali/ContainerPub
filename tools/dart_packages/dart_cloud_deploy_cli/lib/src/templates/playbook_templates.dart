/// Ansible playbook templates with modern syntax (ansible.builtin.*)
/// These are generated on-demand and deleted after deployment

class PlaybookTemplates {
  /// Backend deployment playbook template
  static String backend({
    String appDir = '/opt/dart_cloud',
    String composeFile = 'docker-compose.yml',
    String containerRuntime = 'podman',
    String projectName = 'dart_cloud',
    String backendService = 'backend-cloud',
    String envFile = '.env',
  }) =>
      '''
---
# Ansible Playbook: Backend Deployment
# Generated by dart_cloud_deploy CLI

- name: Deploy Dart Cloud Backend
  hosts: dart_cloud_servers
  become: true
  vars:
    app_dir: $appDir
    compose_file: $composeFile
    container_runtime: $containerRuntime
    project_name: $projectName
    backend_service: $backendService
    env_file: $envFile

  tasks:
    - name: Ensure application directory exists
      ansible.builtin.file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Copy docker-compose file
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../{{ compose_file }}"
        dest: "{{ app_dir }}/{{ compose_file }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags:
        - config

    - name: Copy environment file
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../{{ env_file }}"
        dest: "{{ app_dir }}/{{ env_file }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      tags:
        - config
        - secrets

    - name: Copy Dockerfile
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../Dockerfile.backend"
        dest: "{{ app_dir }}/Dockerfile.backend"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags:
        - config

    - name: Sync backend source code
      ansible.posix.synchronize:
        src: "{{ playbook_dir }}/../"
        dest: "{{ app_dir }}/"
        rsync_opts:
          - "--exclude=.git"
          - "--exclude=.dart_tool"
          - "--exclude=build"
          - "--exclude=.env.example"
      tags:
        - code

    - name: Stop existing backend container
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} stop {{ backend_service }} || true
      args:
        chdir: "{{ app_dir }}"
      changed_when: false
      tags:
        - deploy

    - name: Remove existing backend container
      ansible.builtin.shell: |
        {{ container_runtime }} rm -f {{ project_name }}_{{ backend_service }} || true
      args:
        chdir: "{{ app_dir }}"
      changed_when: false
      tags:
        - deploy

    - name: Build and start backend container
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} up -d --build {{ backend_service }}
      args:
        chdir: "{{ app_dir }}"
      register: backend_start
      changed_when: backend_start.rc == 0
      tags:
        - deploy

    - name: Wait for backend to be healthy
      ansible.builtin.uri:
        url: "http://localhost:8080/health"
        method: GET
        status_code: 200
      register: health_check
      until: health_check.status == 200
      retries: 30
      delay: 2
      tags:
        - deploy
        - health

    - name: Prune unused images
      ansible.builtin.shell: |
        {{ container_runtime }} image prune -f
      args:
        chdir: "{{ app_dir }}"
      changed_when: false
      tags:
        - cleanup

    - name: Display deployment status
      ansible.builtin.debug:
        msg: "Backend deployed successfully! Health check passed."
      tags:
        - deploy
''';

  /// Database deployment playbook template
  static String database({
    String appDir = '/opt/dart_cloud',
    String composeFile = 'docker-compose.yml',
    String containerRuntime = 'podman',
    String projectName = 'dart_cloud',
    String databaseService = 'postgres',
    String postgresUser = 'dart_cloud',
    String postgresDb = 'dart_cloud',
    String dataDir = '/var/lib/dart_cloud/postgres',
  }) =>
      '''
---
# Ansible Playbook: Database Deployment
# Generated by dart_cloud_deploy CLI

- name: Deploy PostgreSQL Database
  hosts: dart_cloud_servers
  become: true
  vars:
    app_dir: $appDir
    compose_file: $composeFile
    container_runtime: $containerRuntime
    project_name: $projectName
    database_service: $databaseService
    postgres_user: $postgresUser
    postgres_db: $postgresDb
    data_dir: $dataDir

  tasks:
    - name: Ensure data directory exists
      ansible.builtin.file:
        path: "{{ data_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags:
        - setup

    - name: Ensure application directory exists
      ansible.builtin.file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags:
        - setup

    - name: Copy docker-compose file
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../{{ compose_file }}"
        dest: "{{ app_dir }}/{{ compose_file }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags:
        - config

    - name: Copy environment file
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../.env"
        dest: "{{ app_dir }}/.env"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      tags:
        - config
        - secrets

    - name: Check if database container exists
      ansible.builtin.shell: |
        {{ container_runtime }} ps -a --format '{{ '{{' }}.Names{{ '}}' }}' | grep -q {{ project_name }}_{{ database_service }}
      register: db_exists
      ignore_errors: true
      changed_when: false
      tags:
        - deploy

    - name: Start database container (if not exists)
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} up -d {{ database_service }}
      args:
        chdir: "{{ app_dir }}"
      when: db_exists.rc != 0
      changed_when: true
      tags:
        - deploy

    - name: Start database container (if stopped)
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} start {{ database_service }}
      args:
        chdir: "{{ app_dir }}"
      when: db_exists.rc == 0
      changed_when: false
      tags:
        - deploy

    - name: Wait for PostgreSQL to be ready
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} exec -T {{ database_service }} pg_isready -U {{ postgres_user }}
      args:
        chdir: "{{ app_dir }}"
      register: pg_ready
      until: pg_ready.rc == 0
      retries: 30
      delay: 2
      changed_when: false
      tags:
        - deploy
        - health

    - name: Run database migrations (if migration files exist)
      ansible.builtin.shell: |
        for f in {{ app_dir }}/migrations/*.sql; do
          if [ -f "\$f" ]; then
            {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} exec -T {{ database_service }} psql -U {{ postgres_user }} -d {{ postgres_db }} -f /migrations/\$(basename \$f)
          fi
        done
      args:
        chdir: "{{ app_dir }}"
      ignore_errors: true
      changed_when: false
      tags:
        - migrations

    - name: Display database status
      ansible.builtin.debug:
        msg: "PostgreSQL database is running and ready!"
      tags:
        - deploy
''';

  /// Backup playbook template
  static String backup({
    String appDir = '/opt/dart_cloud',
    String composeFile = 'docker-compose.yml',
    String containerRuntime = 'podman',
    String projectName = 'dart_cloud',
    String databaseService = 'postgres',
    String postgresUser = 'dart_cloud',
    String postgresDb = 'dart_cloud',
    String backupDir = '/var/backups/dart_cloud',
    int backupRetentionDays = 7,
    String backupType = 'full',
  }) =>
      '''
---
# Ansible Playbook: Database Backup
# Generated by dart_cloud_deploy CLI

- name: Database Backup Operations
  hosts: dart_cloud_servers
  become: true
  vars:
    app_dir: $appDir
    compose_file: $composeFile
    container_runtime: $containerRuntime
    project_name: $projectName
    database_service: $databaseService
    postgres_user: $postgresUser
    postgres_db: $postgresDb
    backup_dir: $backupDir
    backup_retention_days: $backupRetentionDays
    backup_type: $backupType

  tasks:
    - name: Ensure backup directory exists
      ansible.builtin.file:
        path: "{{ backup_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0750'
      tags:
        - setup

    - name: Create timestamp for backup
      ansible.builtin.set_fact:
        backup_timestamp: "{{ ansible_date_time.iso8601_basic_short }}"
      tags:
        - backup

    - name: Create full database backup
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} exec -T {{ database_service }} \\
          pg_dump -U {{ postgres_user }} -d {{ postgres_db }} -F c -b -v \\
          > {{ backup_dir }}/{{ postgres_db }}_{{ backup_timestamp }}.dump
      args:
        chdir: "{{ app_dir }}"
      when: backup_type == 'full'
      changed_when: true
      tags:
        - backup
        - full

    - name: Create SQL backup (human-readable)
      ansible.builtin.shell: |
        {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} exec -T {{ database_service }} \\
          pg_dump -U {{ postgres_user }} -d {{ postgres_db }} --clean --if-exists \\
          > {{ backup_dir }}/{{ postgres_db }}_{{ backup_timestamp }}.sql
      args:
        chdir: "{{ app_dir }}"
      when: backup_type == 'full'
      changed_when: true
      tags:
        - backup
        - full

    - name: Compress backup files
      ansible.builtin.archive:
        path:
          - "{{ backup_dir }}/{{ postgres_db }}_{{ backup_timestamp }}.dump"
          - "{{ backup_dir }}/{{ postgres_db }}_{{ backup_timestamp }}.sql"
        dest: "{{ backup_dir }}/{{ postgres_db }}_{{ backup_timestamp }}.tar.gz"
        format: gz
        remove: true
      when: backup_type == 'full'
      tags:
        - backup
        - compress

    - name: Remove old backups (retention policy)
      ansible.builtin.find:
        paths: "{{ backup_dir }}"
        patterns: "{{ postgres_db }}_*.tar.gz"
        age: "{{ backup_retention_days }}d"
      register: old_backups
      tags:
        - cleanup

    - name: Delete old backup files
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ old_backups.files }}"
      when: old_backups.matched > 0
      tags:
        - cleanup

    - name: List available backups
      ansible.builtin.find:
        paths: "{{ backup_dir }}"
        patterns: "{{ postgres_db }}_*.tar.gz"
      register: available_backups
      tags:
        - list

    - name: Display backup information
      ansible.builtin.debug:
        msg: |
          Backup completed: {{ postgres_db }}_{{ backup_timestamp }}.tar.gz
          Location: {{ backup_dir }}
          Available backups: {{ available_backups.files | length }}
      tags:
        - backup

    # Restore tasks (run with --tags restore)
    - name: Restore database from backup
      when: restore_file is defined
      tags:
        - restore
        - never
      block:
        - name: Check if restore file exists
          ansible.builtin.stat:
            path: "{{ restore_file }}"
          register: restore_stat

        - name: Extract backup archive
          ansible.builtin.unarchive:
            src: "{{ restore_file }}"
            dest: "{{ backup_dir }}"
            remote_src: true
          when: restore_stat.stat.exists

        - name: Restore from dump file
          ansible.builtin.shell: |
            {{ container_runtime }}-compose -p {{ project_name }} -f {{ compose_file }} exec -T {{ database_service }} \\
              pg_restore -U {{ postgres_user }} -d {{ postgres_db }} -c -v \\
              < {{ backup_dir }}/{{ restore_dump_file }}
          args:
            chdir: "{{ app_dir }}"
          when: restore_dump_file is defined
          changed_when: true

    # Verification tasks
    - name: Verify backup integrity
      ansible.builtin.shell: |
        gzip -t {{ backup_dir }}/{{ postgres_db }}_{{ backup_timestamp }}.tar.gz
      register: backup_verify
      when: backup_type == 'full'
      changed_when: false
      tags:
        - verify

    - name: Display verification result
      ansible.builtin.debug:
        msg: "Backup integrity verified successfully!"
      when: backup_verify is defined and backup_verify.rc == 0
      tags:
        - verify
''';
}
