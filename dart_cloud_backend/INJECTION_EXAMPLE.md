# Main.dart Injection - Example

## User's Original Function File

**File: `lib/my_function.dart`**

```dart
import 'package:dart_cloud_function/dart_cloud_function.dart';
import 'package:http/http.dart' as http;

@cloudFunction
class MyFunction extends CloudDartFunction {
  @override
  Future<CloudResponse> handle({
    required CloudRequest request,
    Map<String, String>? env,
  }) async {
    final name = request.body['name'] ?? 'World';
    
    return CloudResponse.json({
      'message': 'Hello, $name!',
      'timestamp': DateTime.now().toIso8601String(),
    });
  }
}
```

## Generated main.dart

After deployment, the system automatically generates this `main.dart`:

```dart
import 'dart:io';
import 'dart:convert';
import 'package:dart_cloud_function/dart_cloud_function.dart';

// User imports from original function file
import 'package:http/http.dart' as http;



/// Auto-generated main.dart for cloud function execution
///
/// This file is generated by the deployment process and should not be modified.
/// It reads the request from request.json, invokes the cloud function,
/// and writes the response to stdout.
void main() async {
  try {
    // Read environment variables
    final env = Platform.environment;

    // Read request from request.json
    final requestFile = File('request.json');
    if (!await requestFile.exists()) {
      _writeError('request.json not found');
      exit(1);
    }

    final requestJson = jsonDecode(await requestFile.readAsString());

    // Parse CloudRequest from JSON
    final request = CloudRequest(
      method: requestJson['method'] as String? ?? 'POST',
      path: requestJson['path'] as String? ?? '/',
      headers: Map<String, String>.from(requestJson['headers'] as Map? ?? {}),
      query: Map<String, String>.from(requestJson['query'] as Map? ?? {}),
      body: requestJson['body'],
    );

    // Instantiate the cloud function
    final function = MyFunction();

    // Execute the function
    final response = await function.handle(
      request: request,
      env: env,
    );

    // Write response to stdout as JSON
    final responseJson = {
      'statusCode': response.statusCode,
      'headers': response.headers,
      'body': response.body,
    };

    stdout.writeln(jsonEncode(responseJson));
    exit(0);
  } catch (e, stackTrace) {
    _writeError('Function execution failed: $e\n$stackTrace');
    exit(1);
  }
}

void _writeError(String message) {
  final errorResponse = {
    'statusCode': 500,
    'headers': {'content-type': 'application/json'},
    'body': {'error': message},
  };
  stdout.writeln(jsonEncode(errorResponse));
}
// Cloud function class code
@cloudFunction
class MyFunction extends CloudDartFunction {
  @override
  Future<CloudResponse> handle({
    required CloudRequest request,
    Map<String, String>? env,
  }) async {
    final name = request.body['name'] ?? 'World';
    
    return CloudResponse.json({
      'message': 'Hello, $name!',
      'timestamp': DateTime.now().toIso8601String(),
    });
  }
}
```

## Key Benefits

### 1. **Self-Contained**
The generated `main.dart` contains the complete function code, making it:
- Easy to debug (all code in one file)
- No import path issues
- Portable across different directory structures

### 2. **Preserves User Code**
- Keeps all user imports (except `dart_cloud_function` which is already imported)
- Preserves the exact class implementation
- Maintains annotations and comments

### 3. **Clean Separation**
- User writes only the function logic
- System generates the boilerplate
- No manual main() function needed

## How It Works

### 1. **Code Analysis**
```dart
// AST visitor extracts:
- Class name: "MyFunction"
- Class code: "@cloudFunction class MyFunction extends..."
- User imports: "import 'package:http/http.dart' as http;"
```

### 2. **Code Embedding**
```dart
// Generated main.dart structure:
1. Standard imports (dart:io, dart:convert, dart_cloud_function)
2. User's imports (http, etc.)
3. User's complete class code
4. Auto-generated main() function
5. Error handling helper
```

### 3. **Execution**
```
Container starts → main.dart runs → Reads request.json → 
Instantiates MyFunction → Calls handle() → Writes response → Exit
```

## Example with Multiple Imports

**User's function:**
```dart
import 'package:dart_cloud_function/dart_cloud_function.dart';
import 'package:http/http.dart' as http;
import 'package:crypto/crypto.dart';
import 'dart:convert';

@cloudFunction
class HashFunction extends CloudDartFunction {
  @override
  Future<CloudResponse> handle({
    required CloudRequest request,
    Map<String, String>? env,
  }) async {
    final input = request.body['text'] ?? '';
    final bytes = utf8.encode(input);
    final hash = sha256.convert(bytes);
    
    return CloudResponse.json({
      'hash': hash.toString(),
    });
  }
}
```

**Generated main.dart will include:**
```dart
// User imports from original function file
import 'package:http/http.dart' as http;
import 'package:crypto/crypto.dart';
import 'dart:convert';

// Cloud function class code
@cloudFunction
class HashFunction extends CloudDartFunction {
  // ... complete class code ...
}
```

## Advantages Over Import Approach

### ❌ Old Approach (Import-based)
```dart
import 'lib/my_function.dart'; // Path issues, relative imports
```

Problems:
- Import path resolution issues
- Nested directory structures break imports
- Hard to debug (code split across files)
- Package structure dependencies

### ✅ New Approach (Code Embedding)
```dart
// Complete class code embedded here
@cloudFunction
class MyFunction extends CloudDartFunction { ... }
```

Benefits:
- ✅ No import path issues
- ✅ Self-contained single file
- ✅ Easy to debug
- ✅ Works with any directory structure
- ✅ Preserves all user code and imports
